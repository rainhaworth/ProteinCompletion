# Inputs:
#   - Completed protein sequence
#   - List of residue indices that were NOT generated by the model

import os
import esm
from esm.sdk.api import ESMProtein, GenerationConfig


class StructureEvaluator:
    def __init__(self, model_id, api_key = None):
        """
        Wrapper around an ESM-3 structure-generation model that
        predicts structure and summarizes pTM / pLDDT on generated vs non-generated residues.

        Args:
            model_id: ESM-3 model identifier (e.g. "esm3_t30_150M_UR50D")
            api_key:  EvolutionaryScale API key. If None, will try env var ESM_API_KEY.
        """
        # Prefer explicit API key, then fall back to environment
        self.api_key = api_key or os.getenv("ESM_API_KEY")
        if not self.api_key:
            raise RuntimeError("ESM_API_KEY not provided via argument or environment")

        # Initialize Forge client for the chosen ESM-3 model
        # (Assumes esm.sdk.client(...) is the correct entry point per the ESM docs.)
        self.model = esm.sdk.client(model_id, token=self.api_key)

    @staticmethod
    def pick_num_steps(L):
        """
        Heuristic for ESM-3 structure-track refinement rounds (num_steps)
        given a fully specified sequence of length L.
        Caps for diminishing returns and credit efficiency.
        """
        # Slightly scale with length; cap to avoid wasted credits
        if L <= 60:
            return 8   # tiny/mini proteins stabilize fast
        if L <= 120:
            return 10
        if L <= 200:
            return 12
        if L <= 300:
            return 14
        if L <= 500:
            return 16
        if L <= 800:
            return 18
        return 20  # upper cap—rarely worth going higher

    def generate_structure(
        self,
        sequence,
        non_generated_indices,
        pdb_out = "predicted_structure.pdb",
    ):
        """
        Generate and evaluate a predicted structure for a given sequence.

        Args:
            sequence: The complete protein sequence.
            non_generated_indices: Indices (0-based) corresponding to residues
                that were NOT generated (i.e., were given / constrained).
            pdb_out: Output filename for the predicted structure (PDB format).

        Returns:
            ptm (float): Global pTM score.
            mean_generated_plddt (float): Mean pLDDT over generated residues.
            mean_non_generated_plddt (float): Mean pLDDT over non-generated residues.
        """
        L = len(sequence)

        # Basic sanity check on indices
        if any(i < 0 or i >= L for i in non_generated_indices):
            raise ValueError("non_generated_indices contains out-of-range positions")

        steps = self.pick_num_steps(L)
        print(steps)

        # Create protein container and run structure generation
        protein = ESMProtein(sequence=sequence)
        protein = self.model.generate(
            protein,
            GenerationConfig(
                track="structure",  # generate 3D structure
                num_steps=steps,    # refinement rounds
            ),
        )

        # Guard: if generate() failed, it may have returned an error object
        if not isinstance(protein, ESMProtein) or not hasattr(protein, "to_pdb"):
            raise RuntimeError(f"ESM structure generation failed: {protein}")

        # Save predicted structure
        protein.to_pdb(pdb_out)

        # Extract pTM (scalar tensor → float)
        ptm = protein.ptm.item()

        # Extract per-residue pLDDT (1D tensor of shape [L])
        plddt = protein.plddt  # torch.Tensor / array-like

        # Infer generated indices (complement of non-generated)
        all_indices = set(range(L))
        non_gen_set = set(non_generated_indices)
        generated_indices = sorted(all_indices - non_gen_set)

        if not generated_indices:
            raise ValueError("No generated residues inferred (complement is empty).")

        # Compute mean pLDDT for generated residues
        generated_plddt = plddt[generated_indices]
        mean_generated_plddt = generated_plddt.mean().item()

        # Compute mean pLDDT for non-generated residues
        non_generated_plddt = plddt[non_generated_indices]
        mean_non_generated_plddt = non_generated_plddt.mean().item()

        return ptm, mean_generated_plddt, mean_non_generated_plddt